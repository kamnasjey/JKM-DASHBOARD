# ===========================================
# JKM Dashboard - Environment Variables
# Copy this file to .env.local and fill values
# ===========================================

# ===== LAUNCH MODE =====
# "coming-soon" = Shows Coming Soon page (for pre-launch testing)
# "live" = Shows full product landing page
NEXT_PUBLIC_LAUNCH_MODE="live"

# ===== DATABASE (REQUIRED) =====
# Production: Use Postgres connection string (Vercel Postgres / Supabase / Neon)
# Example: postgresql://user:password@host:5432/dbname?sslmode=require
# Local dev: Can use SQLite => file:./prisma/dev.db (change schema.prisma provider too)
DATABASE_URL="postgresql://..."

# ===== NEXTAUTH (REQUIRED) =====
# Production: https://jkmcopilot.com or your actual domain
NEXTAUTH_URL="http://localhost:3000"
# Generate with: openssl rand -base64 32
NEXTAUTH_SECRET="generate-a-secure-secret-here"

# ===== GOOGLE OAUTH (REQUIRED for Google login) =====
GOOGLE_CLIENT_ID=""
GOOGLE_CLIENT_SECRET=""

# ===== STRIPE (OPTIONAL - for billing gating) =====
# Billing is disabled by default in Firestore-only mode.
# Set BILLING_DISABLED=0 and configure Stripe to enable.
BILLING_DISABLED=1
STRIPE_SECRET_KEY=""
STRIPE_WEBHOOK_SECRET=""
STRIPE_PRICE_ID=""

# ===== AI (OPTIONAL - Strategy Maker chat) =====
# Required only if you want `/api/strategy-maker/chat` to work.
OPENAI_API_KEY=""

# ===== BACKEND API (REQUIRED) =====
# Internal API key for backend proxy (server-side only, never expose to client)
BACKEND_INTERNAL_API_KEY=""

# Legacy proxy routes (strategies share/import) still use these:
INTERNAL_BACKEND_URL="http://localhost:8000"
INTERNAL_API_KEY=""

# ===== DASHBOARD INTERNAL API (REQUIRED) =====
# Used by the Python backend to call /api/internal/user-data/* routes.
# Generate a secure key: openssl rand -base64 32
DASHBOARD_INTERNAL_API_KEY=""

# ===== USER DATA PROVIDER (REQUIRED) =====
# Controls whether the dashboard uses Firestore as the canonical user-data store.
# Valid: "firebase" (recommended)
USER_DATA_PROVIDER="firebase"

# The internal endpoints include:
# - GET/PUT /api/internal/user-data/strategies/{userId}
# - GET/POST /api/internal/user-data/signals (list/upsert)
# - GET      /api/internal/user-data/users (list paid users)
# - GET/PUT  /api/internal/user-data/users/{userId} (prefs + identity)
# - GET      /api/internal/user-data/health (health check)

# ===== FIREBASE (REQUIRED - Canonical User Data Store) =====
# Firestore is now the canonical source of truth for ALL user data:
# - User identity (email, name, has_paid_access)
# - User preferences (telegram_chat_id, scan_enabled, etc.)
# - User strategies (array in user doc)
# - User signals (subcollection: users/{userId}/signals/{signalKey})

# Firebase Web App config (client-side, for Firebase Auth if used)
NEXT_PUBLIC_FIREBASE_API_KEY=""
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=""
NEXT_PUBLIC_FIREBASE_PROJECT_ID=""
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=""
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=""
NEXT_PUBLIC_FIREBASE_APP_ID=""
NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID=""

# Firebase Admin (server-side) - pick ONE method:
# Option A) Full JSON (recommended on Vercel as a single secret)
FIREBASE_ADMIN_SERVICE_ACCOUNT_JSON=""
# Option B) Split fields
FIREBASE_ADMIN_PROJECT_ID=""
FIREBASE_ADMIN_CLIENT_EMAIL=""
# IMPORTANT: private key must keep newlines. On Vercel, paste with \n or store as multiline secret.
FIREBASE_ADMIN_PRIVATE_KEY=""

# ===== OWNER / ADMIN BYPASS (OPTIONAL) =====
# Comma-separated emails that bypass paid access check
OWNER_ADMIN_EMAILS=""

# ===== ACCESS CONTROL (OPTIONAL) =====
# Comma-separated emails allowed to access gated areas (if enabled by routes).
ALLOWED_EMAILS=""

# ===== WEBSOCKET (OPTIONAL) =====
# Only set if you have a dedicated WebSocket server
# Leave empty if backend handles realtime caching
# NEXT_PUBLIC_WS_URL="wss://..."

# ===========================================
# ARCHITECTURE NOTES
# ===========================================
# 
# Firebase Firestore is the canonical user database:
#   Collection: users/{userId}
#   Fields:
#     - user_id (string)
#     - email (string|null)
#     - name (string|null)
#     - has_paid_access (boolean)
#     - plan (string|null)
#     - plan_status (string|null)
#     - telegram_chat_id (string|null)
#     - telegram_enabled (boolean|null)
#     - telegram_connected_ts (number|null)
#     - scan_enabled (boolean|null)
#     - strategies (array)
#     - updatedAt (string ISO)
#   Subcollection:
#     - users/{userId}/signals/{signalKey}
#
# Prisma (PostgreSQL) is used for:
#   - NextAuth sessions
#   - Stripe billing integration
#   - Initial user registration (then synced to Firestore)
#
# Python backend:
#   - Does NOT have Firebase credentials
#   - Accesses user data via dashboard internal API only
#   - Requires: DASHBOARD_BASE_URL + DASHBOARD_INTERNAL_API_KEY
